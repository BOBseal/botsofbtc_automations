// SPDX-License-Identifier:  MIT
//Deployed Instance - 0xe399c9FF39119be839C354Bce2eB5ad19D2c7075

pragma solidity ^0.8.20;
import "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import "openzeppelin-contracts/contracts/token/ERC721/ERC721.sol";
import "openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "openzeppelin-contracts/contracts/access/Ownable.sol";
import {ERC2981} from "openzeppelin-contracts/contracts/token/common/ERC2981.sol";

/*
Features: 
    Each NFT's Original Minter is Eligible to Earn all the Royalty Generated by user's minted id from secondary sales in Native Token , Mint once and earn lifetime from royalty
*/
contract BOTSOFBITCOIN is ERC721, ERC721URIStorage, Ownable, ERC2981{

    uint public totalSupply = 10000;
    //uint internal defaultAllocation = (138_000_000 * (10 ** 18))/totalSupply;
    event Wrap(uint indexed  id , uint amount , address indexed from);
    event Unwrap(uint indexed  id , uint amount , address indexed to);
    event Burn(uint indexed  id , address indexed from);

    struct MultiUri{
        uint totalUris;
        uint activeIndex;
        mapping(uint => string) _uris;
    }

    mapping (address => bool) internal Managers;
    mapping (uint => MultiUri) internal _extendedUris;
    mapping (uint => bool) internal _uriExtensionActive;
    constructor()
        ERC721("BOTS OF BITCOIN", "BOB")
        Ownable(msg.sender)
    {   
        //Royalty of 6.9%
        _setDefaultRoyalty(msg.sender, 690);
        Managers[msg.sender]= true;        
    }

    function _baseURI() internal pure override returns (string memory) {
        return "ipfs://bafybeibwpkk25hj72ildehlxcowzbne3v6yi5b3bqgy3zip6iw3g2q6t5u";
    }
    /// returns => total saved uri , active uri index
    function getMultiUriData(uint id) public view returns(uint,uint){
        return (_extendedUris[id].totalUris,_extendedUris[id].activeIndex);
    }
    function getUri(uint id , uint index) public view returns(string memory){
        return _extendedUris[id]._uris[index];
    }

    function burn(uint id) public {
        require(_requireOwned(id) == msg.sender);
        _burn(id);
        emit Burn(id, msg.sender);
    }
    // useState => global use state whether id is using uri extensions as primary
    function setExtendedUri(uint tokenId , uint uriIndex, bool state) public returns(bool){
        require(Managers[msg.sender],"not allowed");
        require(abi.encode(_extendedUris[tokenId]._uris[uriIndex]).length >0,"empty slot");
        _uriExtensionActive[tokenId] = state;
        _extendedUris[tokenId].activeIndex = uriIndex;
        return true;
    }

    function addExtendedUri(uint tokenId, string memory _uri) public returns(bool){
        require(Managers[msg.sender],"not allowed");
        uint index = _extendedUris[tokenId].totalUris;
        _extendedUris[tokenId].totalUris = index + 1;
        _extendedUris[tokenId]._uris[index] = _uri;
        return true;
    }

    function safeMint(address to, uint256 tokenId, string memory uri)
        public
    {
        require(Managers[msg.sender],"not allowed");
        require(tokenId <= totalSupply);
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
        _setTokenRoyalty(tokenId , to , 690);
    }

    // The following functions are overrides required by Solidity.
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        if(!_uriExtensionActive[tokenId]){
            return super.tokenURI(tokenId);   
        } else {
            return _getActiveUri(tokenId);
        }
    }

    function _getActiveUri(uint tokenId) internal view returns(string memory){
        uint uriSlot = _extendedUris[tokenId].activeIndex;
        return _extendedUris[tokenId]._uris[uriSlot];
    }

    function setRoyalty(address reciever, uint96 fraction) public  onlyOwner{
        _setDefaultRoyalty(reciever,  fraction);
    }

    function addManager(address a , bool state) public onlyOwner{
        Managers[a] = state;
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721URIStorage, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
